#include <iostream>
#include <cstdio>
using namespace std;


/*

有一个神奇的口袋，总的容积是40，用这个口袋可以变出一些物品，这些物品的总体积必须是40。John现在有n个想要得到的物品，每个物品的体积分别是a1，a2……an。John可以从这些物品中选择一些，如果选出的物体的总体积是40，那么利用这个神奇的口袋，John就可以得到这些物品。现在的问题是，John有多少种不同的选择物品的方式。

输入的第一行是正整数n (1 <= n <= 20)，表示不同的物品的数目。接下来的n行，每行有一个1到40之间的正整数，分别给出a1，a2……an的值。

输出不同的选择物品的方式的数目。

输入：
2
12
28
3
21
10
5
输出：
1
0

思路：
入的体积数存入了数组,利用数组下标表示每一个物品的体积（从1开始，表示第一个物品）
从最后一个往前取可以分为两个情况
1.我们不取最后一个,取前面的就可以凑成40
2.我们取最后一个,那么我们接着取前面的话就要将体积凑成40减去我们已经取得的物品的体积
两者相加就是取法的总数。
递归的边界就是 当b==0,也就是我们前面取到的物品已经凑到了b,所以不需要再继续取物品去凑体积的时候,表示我们已经凑成了一种情况,返回1。
当a<=0时,也就是前面已经没有东西可取了的时候,表示我们凑不成目标体积b了,返回0

*/

const int maxn = 21;

int pocket[maxn];

int choose(int a, int b) { // 从前a个物品中选出体积总和为b的物品
	if (b == 0) return 1; // 前面的物品正好凑到b
	if (a <= 0) return 0; // 没有东西可以取了，返回0
	return choose(a-1,b) + choose(a-1, b-pocket[a]);
}


int main(int argc, char *argv[]) {
	int n;
	while (scanf("%d", &n) != EOF) {
		for (int i = 1; i <= n; i++) {
			scanf("%d", &pocket[i]);
		}
		printf("%d\n", choose(n, 40));
	}
}